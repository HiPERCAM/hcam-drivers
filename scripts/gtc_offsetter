#!/usr/bin/env python
from __future__ import print_function, division, unicode_literals
import glob
import os
import sys
import time
import datetime

import tornado.ioloop
from tornado.web import RequestHandler, Application, url
from watchdog.observers import Observer
from watchdog.events import PatternMatchingEventHandler


def sendSeqTrigger():
    print('ngcbCmd seq trigger')


def scheduleTrigger(inTime):
    """
    Schedule a sendSeqTrigger request

    This can be called from any thread to schedule a trigger. It is needed
    because ``IOLoop.add_timeout`` is not thread safe and so can only be
    called from the IOLoop's own thread.

    Parameters
    ----------
    inTime : float
        time in seconds to wait before sending trigger
    """
    tornado.ioloop.IOLoop.instance().add_timeout(
        datetime.timedelta(seconds=inTime), sendSeqTrigger
    )


class FITSWriteHandler(PatternMatchingEventHandler):
    patterns = ['*.fits']

    def __init__(self, path, *args, **kwargs):
        super(FITSWriteHandler, self).__init__()
        self.path = path
        try:
            pattern = os.path.join(self.path, self.patterns[0])
            self.existing_runs = glob.glob(pattern)
        except:
            self.existing_runs = []
        # used to avoid responding to very recent
        # events which may be duplicates.
        self.debounce_time = 0.1
        self.last_event = 0

    def check_debounce(self):
        """
        Avoid handling very closely occurring filesystem events.abs

        Sometimes there are two or more rapid filesystem events when
        a frame is written. This routine checks if another event
        as happened recently, and returns False if so.
        """
        first_event = False
        if time.time() - self.last_event > self.debounce_time:
            self.last_event = time.time()
            first_event = True
        else:
            self.last_event = time.time()
        return first_event

    def on_modified(self, event):
        if self.check_debounce():
            if event.src_path == self.existing_runs[-1]:
                # latest file has just been written to

                # send telescope offset command
                print('sending tel offset')

                # assume offset takes X seconds
                # trigger sequencer to start again in X s
                tornado.ioloop.IOLoop.instance().add_callback(
                    scheduleTrigger, 3
                )

    def on_created(self, event):
        self.check_debounce()
        # if we don't know about this, it's a new run.
        if event.src_path not in self.existing_runs:
            self.existing_runs.append(event.src_path)


class StartHandler(RequestHandler):
    def initialize(self, db):
        self.db = db

    def get(self):
        db['observer'] = make_observer(db['path'])
        db['observer'].start()


class StopHandler(RequestHandler):
    def initialize(self, db):
        self.db = db

    def get(self):
        if db.get('observer'):
            db['observer'].stop()


class EchoHandler(RequestHandler):
    def initialize(self, db):
        self.db = db

    def get(self):
        print('echo')


def make_observer(path):
    observer = Observer()
    handler = FITSWriteHandler(path)
    observer.schedule(handler, path=path, recursive=False)
    observer.daemon = True
    return observer


if __name__ == "__main__":
    path = sys.argv[1]

    db = dict(path=path)
    app = Application([
        url(r'/start', StartHandler, dict(db=db), name='start'),
        url(r'/stop', StopHandler, dict(db=db), name='stop'),
        url(r'/echo', EchoHandler, dict(db=db), name='echo')
    ])
    app.listen(5001)
    tornado.ioloop.IOLoop.current().start()
