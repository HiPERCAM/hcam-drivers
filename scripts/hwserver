#!/usr/bin/env python
from __future__ import print_function, division, unicode_literals
import Pyro4
from hcam_widgets.globals import Container
from hcam_drivers.config import load_config
from hcam_drivers.hardware import (vacuum, meerstetter, unichiller, rack,
                                   slide, honeywell)


@Pyro4.behavior(instance_mode='single')
class HardwareProxy:
    """
    A class to manage access to hardware running on HiPERCAM

    Only one instance of this class is ever created. It in turn has delegates
    of all the hardware on HiPERCAM, so there is only one instance on the
    whole system for any single piece of hardware. As long as the hardware code
    is threadsafe, this should all be fine...
    """
    def __init__(self):
        print('creating Hardware proxy (should only happen once)')
        g = Container()
        g.cpars = dict()
        load_config(g)
        cpars = g.cpars

        # make objects for talking to hardware
        self.gauges = [vacuum.PDR900(cpars['termserver_ip'], port) for port in cpars['vacuum_ports']]
        self.ms = [meerstetter.MeerstetterTEC1090(ip, 50000) for ip in cpars['meerstetter_ip']]
        if cpars['telins_name'].lower() == 'wht':
            self.chiller = unichiller.UnichillerMPC(cpars['termserver_ip'],
                                                    cpars['chiller_port'])
        else:
            self.chiller = rack.GTCRackSensor()
        self.honey = honeywell.Honeywell(g.cpars['honeywell_ip'], 502)
        ip, port = cpars['termserver_ip'], cpars['slide_port']
        self.focal_plane_slide = slide.Slide(None, ip, port)

    def lookup_hw(self, device, prop):
        """
        Parses device requested from server and matches to Python object
        """
        try:
            device = device.lower()
            if device.startswith('ccd'):
                ccdnum = int(device[-1])
                if prop == 'flow':
                    return self.honey
                elif prop == 'pressure':
                    return self.gauges[ccdnum-1]
                else:
                    ms1, ms2 = self.ms
                    mapping = {1: ms1, 2: ms1, 3: ms1, 4: ms2, 5: ms2}
                    return mapping[ccdnum]

            elif device in ['rack', 'chiller']:
                return self.chiller

            elif device.startswith('ngc'):
                return self.honey

            elif device.startswith('slide'):
                return self.focal_plane_slide
            else:
                raise KeyError('no such device')
        except Exception as err:
            raise ValueError('hardware lookup failed: ' + str(err))

    def lookup_get_method(self, device, prop):
        """
        Looks up appropriate method to call to FIND a property from device
        """
        # lookup table of method, args
        device = device.lower()
        if device.startswith('ngc'):
            if prop != 'flow':
                raise KeyError('no such property')
            else:
                return ('read_pen', ('ngc',))

        if device in ['rack', 'chiller']:
            if prop == 'temperature':
                return 'temperature', None
            else:
                raise KeyError('no such property')

        if device.startswith('ccd'):
            ccdnum = int(device[-1])
            meerstetter_address = 1 + ((ccdnum-1) % 3)
            if prop == 'flow':
                return ('read_pen', ('ccd{:d}'.format(ccdnum),))
            elif prop == 'pressure':
                return 'pressure', None
            elif prop == 'current':
                return 'get_current', (meerstetter_address,)
            elif prop == 'temperature':
                return 'get_ccd_temp', (meerstetter_address,)
            elif prop == 'heatsink':
                return 'get_heatsink_temp', (meerstetter_address,)
            elif prop == 'peltier_status':
                return 'get_status', (meerstetter_address,)
            elif prop == 'setpoint':
                return 'get_setpoint', (meerstetter_address,)
            else:
                raise KeyError('no such property')

        if device.startswith('slide'):
            if prop == 'position':
                return 'report_position', None
            else:
                raise KeyError('no such property')

    def lookup_set_method(self, device, prop, value):
        """
        Looks up method to SET a property, or send command to a device
        """
        device = device.lower()
        if device.startswith('ngc'):
            raise ValueError('no settable properties on this device')

        elif device.startswith('slide'):
            if prop == 'position':
                if value is None:
                    raise ValueError('must supply a position for slide')
                return 'move_absolute', (value, 'px')
            if prop in ('home', 'enable', 'disable',
                        'stop', 'reset', 'restore'):
                return prop, None

        elif device.startswith('ccd'):
            ccdnum = int(device[-1])
            meerstetter_address = 1 + ((ccdnum-1) % 3)
            if prop == 'tecreset':
                return 'reset_tec', (meerstetter_address,)
            elif prop == 'setpoint':
                return 'set_ccd_temp', (meerstetter_address, value)
            else:
                raise ValueError('not a settable property')

        else:
            raise KeyError('no settable properties on this device')

    @Pyro4.expose
    def get_value(self, name, prop):
        hw = self.lookup_hw(name, prop)
        meth, args = self.lookup_get_method(name, prop)
        try:
            meth = getattr(hw, meth)
        except Exception:
            raise ValueError('method lookup on device has failed')

        try:
            if callable(meth):
                if args is not None:
                    value = meth(*args)
                else:
                    value = meth()
            else:
                value = meth
        except Exception as err:
            raise RuntimeError('command execution failed: ' + str(err))

        return value

    @Pyro4.expose
    def send_command(self, name, prop, value=None):
        hw = self.lookup_hw(name, prop)
        meth, args = self.lookup_set_method(name, prop, value)
        try:
            meth = getattr(hw, meth)
        except Exception:
            raise ValueError('method lookup on device has failed')

        try:
            if args is not None:
                value = meth(*args)
            else:
                value = meth()
        except Exception as err:
            raise RuntimeError('command execution failed:' + str(err))
        return value


if __name__ == "__main__":
    daemon = Pyro4.Daemon(port=5002)
    uri = daemon.register(HardwareProxy, objectId='hwserver')
    print('HWServer daemon running')
    print('Access hardware at {}'.format(uri))
    daemon.requestLoop()
